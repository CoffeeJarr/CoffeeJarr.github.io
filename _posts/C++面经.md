# C++面经

项目源码链接：[https://ezlippi.com/blog/2014/12/c-open-project.html](https://ezlippi.com/blog/2014/12/c-open-project.html)

- 1、C/C++的区别
    
    **C语言特点：**
    
    1. 作为一种面向过程的结构化语言，易于调试和维护；
    2. 表现能力和处理能力极强，可以直接访问内存的物理地址；
    3. C语言实现了对硬件的编程操作，也适合于应用软件的开发；
    4. C语言还具有效率高，可移植性强等特点。
    
    **C++语言特点：**
    
    1. 在C语言的基础上进行扩充和完善，使C++兼容了C语言的面向过程特点，又成为了一种面向对象的程序设计语言；
    2. 可以使用抽象数据类型进行基于对象的编程；
    3. 可以使用多继承、多态进行面向对象的编程；
    4. 可以担负起以模版为特征的泛型化编程。
    
    **C++与C语言的本质差别：**
    
           在于C++是面向对象的，而C语言是面向过程的。或者说C++是在C语言的基础上增加了面向对象程序设计的新内容，是对C语言的一次更重要的改革，使得C++成为软件开发的重要工具。
    
- struct 于 c 和 c++ 的区别
    
    [](https://www.jianshu.com/p/900ad065973d)
    
- ****C++中指针和引用的区别****
    
    [](https://blog.csdn.net/weikangc/article/details/49762929)
    
- 2、C++文件编译与执行的四个阶段
    
    编译器把源文件转换为可执行目标文件的过程
    
    1. **预处理**：根据文件中的预处理指令（#开头）来修改源文件的内容
    2. **编译**：编译成汇编文件
    3. **汇编**：把汇编文件翻译成目标机器指令，即可重定位目标文件
    4. **链接**：链接可重定位目标文件（与printf.o等单独预编译的目标文件），生成可执行目标文件
- 3、C/C++ 编译的程序占用的内存分以下 5 个部分
    
    1. 栈区———程序运行时编译器自动分配，存放函数的参数值，局部变量值等，对应的作用域用完就会释放。有些编译器默认栈的大小为1mb，因此不能定义过大的数组。地址由高向低减少
    
    2. 堆区———一般由程序员分配释放，若程序员未释放，程序结束时由os释放，分配方式类似链表。所以会产生内存碎片，大小不受限，理论上每个程序可达4g。地址由低向高增加
    
    3. 全局区（静态区）———编译器编译时期分配，全局变量/静态变量，初始化一起，未初始化一起，程序结束后os释放
    
    4. 常量存储区———所有常量存放，程序结束后os释放
    
    5. 程序代码区———存放程序的二进制代码
    
- 4、重载（overload）、重写(override)、重定义
    - 重载：函数名相同，参数列表（函数的特征标）不同，只是在类的内部存在   P276
        
        函数重载除了形参类型和个数不同可以实现外，const常量函数和非常量函数也可以实现函数重载
        
    - 重写：也叫覆盖，子类重新定义父类中有相同名称和参数的虚函数，在继承关系之间。C++利用虚函数实现多态。重写函数必须有相同的类型，名称和参数列表。
    - 重定义：也叫隐藏，子类重新定义与父类有相同名称的非虚函数，参数列表可以不同，会导致父类方法的隐藏。除非调用的时候强制转换成父类型。
    
    重写函数的访问修饰符可以不同。尽管父类的virtual方法是private的，派生类中重写改写为public,protected也是可以的。这是因为被virtual修饰的成员函数，无论他们是private/protect/public的，都会被统一放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表，因此就允许子类对这些虚函数进行重写。
    
- ****C++ const常量成员函数****
    
    [C++ const常量成员函数_NearXDU的博客-CSDN博客](https://blog.csdn.net/zhangxiao93/article/details/50599104)
    
- 5、函数指针
    
    [万字长文系统梳理C++函数指针_三级狗的博客-CSDN博客](https://blog.csdn.net/Three_dog/article/details/107817150)
    
    函数指针和函数名还是有点区别的，他们虽然都指向了函数在内存的入口地址，但函数指针本身是个指针变量，对他做`&`取地址的话会拿到这个变量本身的地址去。
    
    而对函数名做`&`取址，得到的还是函数的入口地址。如果是类成员函数指针，差别更加明显。
    
- 6、auto 与 typedef
    
    [【C++】C++中typedef、auto与decltype的作用](https://www.cnblogs.com/HDK2016/p/10250039.html)
    
- 7、深拷贝和浅拷贝的区别
    
    如果一个类拥有资源，当这个类的对象发生复制过程的时候，如果资源重新分配了就是深拷贝；反之没有重新分配资源，就是浅拷贝。
    
- 8、哪些成员函数不能被继承
    
    C++中，并不是所有的成员函数都能被子类继承，有三类成员函数不能被子类继承，分别是：构造函数（包括拷贝构造）、析构函数、赋值运算符重载函数。
    
    **1. 构造函数** 
    
    构造方法用来初始化类的对象，与父类的其它成员不同，它不能被子类继承（子类可以继承父类所有的成员变量和成员方法，但不继承父类的构造方法）。因此，在创建子类对象时，为了初始化从父类继承来的数据成员，系统需要调用其父类的构造方法。 　　
    
    如果没有显式的构造函数，编译器会给一个默认的构造函数，并且该默认的构造函数仅仅在没有显式地声明构造函数情况下创建。 构造原则如下：
    
    1. 如果子类没有定义构造方法，则调用父类的无参数的构造方法。
    
    2. 如果子类定义了构造方法，不论是无参数还是带参数，在创建子类的对象的时候,首先执行父类无参数的构造方法，然后执行自己的构造方法。
    
    3. 在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数，则会调用父类的默认无参构造函数。
    
    4. 在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类自己提供了无参构造函数，则会调用父类自己的无参构造函数。
    
    5. 在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类只定义了自己的有参构造函数，则会出错（**如果父类只有有参数的构造方法，则子类必须显示调用此带参构造方法**）。
    
    6. 如果子类调用父类带参数的构造方法，需要用初始化父类成员对象的方式
    
    **2. 析构函数** 
    
    析构函数也不会被子类继承，只是在子类的析构函数中会调用父类的析构函数。
    
    **如果没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时**，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成**内存泄露**
    
    **3. 赋值运算符重载函数** 
    
    赋值运算符重载函数也不会被子类继承，只是在子类的赋值运算符重载函数中会调用父类的赋值运算符重载函数。
    
    **“赋值运算符重载函数”不是不能被派生类继承，而是被派生类的默认“赋值运算符重载函数”给覆盖了。**
    
    [为什么C++赋值运算符重载函数不能被继承？_pbmichael的博客-CSDN博客](https://blog.csdn.net/pbmichael/article/details/1608250?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_aa&utm_relevant_index=5)
    
- 9、构造函数不能为虚函数
    
    1）虚拟函数调用只需要“部分的”信息，即只需要知道函数接口，而不需要对象的具体类型。但是构建一个对象，却必须知道具体的类型信息。如果你调用一个虚拟构造函数，编译器怎么知道你想构建是继承树上的哪种类型呢？所以这在逻辑上是一个悖论。
    
    2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了
    
- 10、基类的析构函数为什么要用virtual虚析构函数（扩展：静态绑定与动态绑定）
    
            直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除**基类指针指向的派生类对象**时就不会触发**动态绑定**，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。
    
    静态绑定和动态绑定是C++多态性的一种特性
    
    1）对象的静态类型和动态类型
    
    静态类型：对象在声明时采用的类型，在编译时确定
    
    动态类型：当前对象所指的类型，在运行期决定，对象的动态类型可变，静态类型无法更改
    
    2）静态绑定和动态绑定
    
    静态绑定：绑定的是对象的静态类型，函数依赖于对象的静态类型，在编译期确定
    
    动态绑定：绑定的是对象的动态类型，函数依赖于对象的动态类型，在运行期确定
    
    **只有虚函数才使用的是动态绑定**，其他的全部是静态绑定
    
- 11、为何要使用多态呢？
    
            封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。**静态多态**，将同一个接口进行不同的实现，根据传入不同的参数（个数或类型不同）调用不同的实现。**动态多态**，则不论传递过来的哪个类的对象，函数都能够通过同一个接口调用到各自对象实现的方法。
    
    - 静态多态
    
           静态多态往往通过函数重载和模版（泛型编程）来实现，具体可见下面代码：
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    //两个函数构成重载
    int add(int a, int b)
    {
        cout<<"in add_int_int()"<<endl;
        return a + b;
    }
    double add(double a, double b)
    {
        cout<<"in add_double_doube()"<<endl;
        return a + b;
    }
    
    //函数模板（泛型编程）
    template <typename T>
    T add(T a, T b)
    {
        cout<<"in func tempalte"<<endl;
        return a + b;
    }
    
    int main()
    {
        cout<<add(1,1)<<endl;					//调用int add(int a, int b)
        cout<<add(1.1,1.1)<<endl;		   	 	//调用double add(double a, double b)
        cout<<add<char>('A',' ')<<endl;		//调用模板函数，输出小写字母a
    }
    ```
    
    - 动态多态
    
           动态多态最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而调用不同的方法。如果没有使用虚函数，即没有利用C++多态性，则利用基类指针调用相应函数的时候，将总被限制在基类函数本身，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用同一个函数，这就无法实现“一个接口，多种实现”的目的了。
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    class Base
    {
    public:
        virtual void func()
        {
            cout << "Base::fun()" << endl;
        }
    };
    
    class Derived : public Base
    {
    public:
        virtual void func()
        {
          cout << "Derived::fun()" << endl;
        }
    
    };
    
    int main()
    {
        Base* b=new Derived;            //使用基类指针指向派生类对象
        b->func();                       //动态绑定派生类成员函数func
    
        Base& rb=*(new Derived);        //也可以使用引用指向派生类对象
        rb.func();
    }
    ```
    
           通过上面的例子可以看出，在使用基类指针或引用指向子类对象时，调用的函数是子类中重写的函数，这样就实现了运行时函数地址的动态绑定，即动态联编。动态多态是通过“继承+虚函数”来实现的，只有在程序运行期间（非编译期）才能判断所引用对象的实际类型，根据其实际类型调用相应的方法。
    
- 12、哪些函数不能声明成虚函数
    
    非成员函数、构造函数、静态成员函数、内联成员函数、友元函数
    
    1. 非成员函数 
        
        非成员函数只能被重载(overload)，不能被继承(override)，而虚函数主要的作用是在继承中实现动态多态，非成员函数早在编译期间就已经绑定函数了，无法实现动态多态，那声明成虚函数还有什么意义呢？
        
    2. 构造函数
        
        要想调用虚函数必须要通过“虚函数表”来进行的，但虚函数表是要在对象实例化之后才能够进行调用。而在构造函数运行期间，还没有为虚函数表分配空间，自然就没法调用虚函数
        
    3. 静态成员函数
        
        1) static成员不属于任何类对象或类实例，所以即使给此函数加上virtual也是没有任何意义的。
        
        2) 静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。、
               虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable。
               对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual。
        
               虚函数的调用关系：this -> vptr -> vtable ->virtual function
        
    4. 内联成员函数
        
                内联函数是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，并且inline函数在编译时被展开，虚函数在运行时才能动态地绑定函数。
        
    5. 友元函数
        
                因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。友元函数不属于类的成员函数，不能被继承。
        
- 13、为何static成员函数不能为const函数
    
          当声明一个非静态成员函数为const时，对this指针会有影响。对于一个Test类中的const修饰的成员函数，this指针相当于Test const *，而对于非const成员函数，this指针相当于Test *。而static成员函数没有this指针，所以使用const来修饰static成员函数没有任何意义。
    
    static在c++中的第五种含义：用static修饰不访问非静态数据成员的类成员函数。这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量。
    
    不能用const的原因：
         `这是C++的规则，const修饰符用于表示函数不能修改成员变量的值，该函数必须是含有this指针的类成员函数，函数调用方式为thiscall，而类中的static函数本质上是全局函数，调用规约是__cdecl或__stdcall,不能用const来修饰它。<span style="line-height:26px">一个静态成员函数访问的值是其参数、静态数据成员和全局变量，而这些数据都不是对象状态的一部分。而对成员函数中使用关键字const是表明：函数不会修改该函数访问的目标对象的数据成员。既然一个静态成员函数根本不访问非静态数据成员，那么就没必要使用const了。`
    
    什么时候使用静态数据成员和静态函数呢？
    
    定义数据成员为静态变量，以表明此全局数据逻辑上属于该类。
    
    定义成员函数为静态函数，以表明此全局函数逻辑上属于该类，而且该函数只对静态数据、全局数据或者参数进行操作，而不对非静态数据成员进行操作。
    
    static的第一种含义：修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。
    
    static的第二种含义：修饰局部变量时，表明该变量的值不会因为函数终止而丢失。
    
    static的第三种含义：修饰函数时，表明该函数只在同一文件中调用。
    
    static的第四种含义：修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归 所有对象共有。
    
    static的第五种含义：修饰类成员函数，如上。
    
- 14、const 修饰函数参数，返回值，函数体
    
    [const 修饰函数参数，返回值，函数体_小李的专栏-CSDN博客](https://blog.csdn.net/lz20120808/article/details/46662569)
    
- 15、如何初始化const和static数据成员
    
    const定义的常量在超出其作用域之后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间。static表示的是静态的。**类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的**。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。
    
    在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate = 2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static
    
    在C++中，const成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。
    
    const数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。
    
    const数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static const。
    
    ```cpp
    class Test{
    public:
    Test():a(0){}
    enum {size1=100,size2=200};
    private:
    const int a;//只能在构造函数初始化列表中初始化
    static int b;//在类的实现文件中定义并初始化
    const static int c;//与 static const int c;相同。
    };
    int Test::b=0;//static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象。
    const int Test::c=0;//注意：给静态成员变量赋值时，不需要加static修饰符，但要加cosnt。
    ```
    
- 16、关键字static有什么作用
    
    修饰：成员变量、成员函数、普通变量、普通函数
    
- 17、关键字const的作用
- 18、#define和const有什么区别
    
    1）#define定义的常量没有类型，所给出的是一个立即数；const定义的常量有类型名字，存放在静态区域
    
    2）处理阶段不同，#define定义的宏变量在预处理时进行替换，可能有多个拷贝，const所定义的变量在编译时确定其值，只有一个拷贝。
    
    3）#define定义的常量是不可以用指针去指向，const定义的常量可以用指针去指向该常量地址
    
    4）#define可以定义简单的函数，const不可以定义函数
    
- 19、结构体struct和共同体union的区别
    
    结构体：将不同类型的数据组合成一个整体，是自定义类型;  共同体：不同类型的几个变量共同占用一段内存
    
    1）结构体中的每个成员都有自己独立的地址，它们是同时存在的； 共同体中的所有成员占用同一段内存，它们不能同时存在；
    
    2）sizeof(struct)是内存对齐后所有成员长度的总和，sizeof(union)是内存对齐后最长数据成员的长度
    
- 20、引用与指针的区别
    
    1：引用是变量的一个别名，内部实现是只读指针
    
    2：引用只能在初始化时被赋值，其他时候值不能被改变，指针的值可以在任何时候被改变
    
    3：引用不能为NULL，指针可以为NULL
    
    4：引用变量内存单元保存的是被引用变量的地址
    
    5：“sizeof 引用" = 指向变量的大小 ， "sizeof 指针"= 指针本身的大小
    
    6：引用可以取地址操作，返回的是被引用变量本身所在的内存单元地址
    
    7：引用使用在源代码级相当于普通的变量一样使用，做函数参数时，内部传递的实际是变量地址
    
    **引用必须初始化的原因：**
    
    定义一般变量时：
    声明：声明变量类型和名字 -> 定义：根据类型分配内存地址空间 -> 初始化：将初始值拷贝到变量的内存地址空间中（三步）
    因此变量的声明，定义和初始化可以分开，不需要一次完成
    
    定义引用类型时：
    将引用绑定到初始化对象（一步）
    因此定义引用类型时必须有初始值对象（必须为左值）
    
- 21、C++中map、hash_map、unordered_map、unordered_set
    
    [https://blog.csdn.net/u013195320/article/details/23046305?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control](https://blog.csdn.net/u013195320/article/details/23046305?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control)
    
- 22、C++虚函数的实现基本原理
    
    [C/C++杂记：虚函数的实现的基本原理](https://www.cnblogs.com/malecrab/p/5572730.html)
    
    [C/C++杂记：深入理解数据成员指针、函数成员指针](https://www.cnblogs.com/malecrab/p/5572119.html)
    
- 23、初始化列表
    
    [C++ 初始化列表 - 翰墨小生 - 博客园](https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html)
    
- 24、堆栈溢出一般是由什么原因导致的？
    
    1.函数调用层次太深。函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。再有，当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址而造成栈溢出。
    2.动态申请空间使用之后没有释放。由于C语言中没有垃圾资源自动回收机制，因此，需要程序主动释放已经不再使用的动态地址空间。申请的动态空间使用的是堆空间，动态空间使用不会造成堆溢出。
    3.数组访问越界。C语言没有提供数组下标越界检查，如果在程序中出现数组下标访问超出数组范围，在运行过程中可能会内存访问错误。
    4.指针非法访问。指针保存了一个非法的地址，通过这样的指针访问所指向的地址时会产生内存访问错误。
    
- 25、this指针的理解和__thiscall的调用方式
    
    [【C++】this指针的理解和__thiscall的调用方式_alidada_blog的博客-CSDN博客__thiscall](https://blog.csdn.net/alidada_blog/article/details/81290323)
    
- 26、多态，虚函数，纯虚函数
    
    **多态**
    
    不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：
    
    （1）在程序运行时的多态性通过继承和虚函数来体现；
    
    （2）在程序编译时多态性体现在函数和运算符的重载上；
    
    **虚函数**
    
    在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。
    
    **纯虚函数**
    
    在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在的纯虚函数不具备函数的功能，一般不能直接被调用。
    
    从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。
    
    抽象类中不仅包括纯虚函数，也可包括虚函数。**抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例**。但仍可使用指向抽象类的指针支持运行时多态性。
    
- 27、迭代器失效的情况
    
    
- 拷贝构造函数和赋值运算符&&深拷贝和浅拷贝
    
    [C++ 拷贝构造函数和赋值运算符](https://www.cnblogs.com/wangguchangqing/p/6141743.html)
    
- 浅谈C++中的几种构造函数
    
    [浅谈C++中的几种构造函数_林多-CSDN博客_c++ 构造函数](https://blog.csdn.net/zxc024000/article/details/51153743)
    
- 智能指针
    
    [第 5 章 智能指针与内存管理](https://changkun.de/modern-cpp/zh-cn/05-pointers/#5-2-std-shared-ptr)
    
- C++强制类型转换
    
    [c++ 四种强制类型转换介绍_ydar95的博客-CSDN博客_简述c++中四种强制类型转换的作用](https://blog.csdn.net/ydar95/article/details/69822540)
    
- 为什么C++赋值运算符重载函数不能被继承？
    
    [为什么C++赋值运算符重载函数不能被继承？_pbmichael的博客-CSDN博客](https://blog.csdn.net/pbmichael/article/details/1608250?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_aa&utm_relevant_index=5)
    
- C++ 中内存对齐原理及作用
    
    [C++ 中内存对齐原理及作用_不很正派的专栏-CSDN博客_内存对齐的目的和原理](https://blog.csdn.net/u012611878/article/details/78995574)
    
- 函数返回值的传递
    
    [（栈帧和函数调用三）函数返回值的传递_bajianxiaofendui的博客-CSDN博客_栈帧 返回值](https://blog.csdn.net/bajianxiaofendui/article/details/103056825)
    
- C++ Template 基础篇（一）：函数模板
    
    [C++ Template 基础篇（一）：函数模板_lezardfu的专栏-CSDN博客_模板函数](https://blog.csdn.net/lezardfu/article/details/56852043)
    
- c++能不能给类的成员变量在声明的时候初始化？
    
    [c++能不能给类的成员变量在声明的时候初始化？ - 编程猎人](https://www.programminghunter.com/article/988999734/)
